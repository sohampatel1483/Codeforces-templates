/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⢃⣀⡀⠀⠀⠀⠀⠀⠀⢾⠀⠀⡐⢀⡂⠀⠰⠀⡴⠀⣠⣀⡀⠰⡀⢀⣴⡿⢻⣷⣿⢿⣷⣶⣶⣶⣶⣶⣶⣿⢻⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢽⣽⣿⣿⣿⣷⣶⣦⣤⣄⣀⣿⡀⠊⣰⣾⣿⣦⣸⠀⢀⣾⡿⣿⣿⣶⣄⣸⣿⢆⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⡃⢉⣿⣿⡎⠙⠿⠻⣟⠿⣿⣇⣸⡿⣿⣯⣿⣿⣄⣿⠉⣿⣿⣿⣻⣿⣿⣿⣿⣿⣿⣿⣿⠙⠉⠛⣽⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣠⣾⣿⠟⠉⠙⠿⢿⣿⡆⠀⠀⠀⠀⠀⠀⠉⢻⣿⣸⣿⣿⣿⣿⣿⣷⣼⡿⣿⣿⣿⡆⠀⢻⣿⣽⣿⣿⣆⠀⠀⢽⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⣾⣿⣿⣿⣢⡀⣠⢞⣽⣎⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⡟⣿⣿⣿⡇⠁⠀⠹⣿⡽⣿⣿⣿⡄⠀⢹⣿⣿⣿⣿⣆⠀⠺⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢠⣿⣿⣿⣿⢟⠉⠻⣿⣿⣿⣿⣧⡄⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣧⠀⠀⠀⠈⠻⣿⣿⣽⣷⡄⠀⠹⣿⣿⣿⣿⣆⢸⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢠⣿⣿⣿⣿⣿⣿⠀⠀⠀⣽⢿⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⡆⠀⠀⠀⠀⠹⣿⣿⣿⣿⡄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⢠⣿⣿⣿⣵⣿⣿⣿⣶⣤⣾⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⠀⢀⠀⠀⠀⠈⢻⣿⣿⣿⣆⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢠⣿⣿⡿⢡⣿⣿⣿⢻⣿⣿⣿⣿⣿⠛⠃⠀⠀⠀⠀⢀⣉⣛⡦⣤⡀⠀⢻⣿⣿⣿⣦⠟⠀⠀⢀⣠⡤⠞⢿⣿⣿⡆⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⣿⣿⠟⢁⣿⣿⣿⠏⣽⣿⣿⣿⡌⢻⡀⠘⢶⣭⣭⣭⣅⣀⣀⡀⠈⠙⠓⢮⢻⣿⣿⣿⣤⠖⠛⠉⠀⠉⠉⠉⢻⣿⣿⣄⣀⣀⠙⣿⣿⣯⠁⠘⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⣿⠏⠀⣾⣿⣿⡟⣼⣿⣿⣿⣿⣿⣸⡇⠀⠀⠙⢦⣄⣀⣤⣼⣿⡿⠛⢿⠗⠀⢿⣿⣿⣿⠀⣾⡛⢉⣉⣩⣽⣿⡿⣿⣿⡛⠀⠀⠈⣿⣿⡇⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠁⠀⣸⣿⣿⡿⢀⣿⣿⣿⣿⣿⣿⡇⢧⠀⠀⠀⠀⠀⠉⠉⠩⣥⣤⣬⠗⠃⠀⠀⠻⣿⣿⣧⠀⠈⠉⠉⠩⠟⠻⠛⠛⣿⣿⠀⠀⢰⢿⢻⣿⣾⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⣸⣿⣿⡟⠀⣿⣿⣿⣿⣿⣿⣿⣧⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣆⠢⠀⠀⠀⠀⢠⡆⠀⠙⣿⣧⠀⣼⢞⡜⣻⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀
⣰⣿⣿⡟⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣧⢳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠙⣿⣿⡄⠀⢀⡀⠀⡞⠀⠀⠀⠙⣿⣆⣯⠞⣽⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀
⣿⣿⠏⠀⢠⣿⣿⠋⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣡⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀
⡿⠃⠀⠀⣿⣿⠋⢰⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⣶⣄⡀⠀
⠀⠀⠀⣼⣿⠋⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⢀⠀⠀⠈⢿⡇⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣮⡙⠿⣿⣷⣦
⠀⠀⢰⣿⠏⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣞⠉⠀⠀⠀⠈⢿⡄⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠙⠻
⠀⠀⣾⡟⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⢀⣀⣀⣀⣀⣈⣁⠀⠀⠀⠀⠘⣇⠀⠀⢀⣴⣿⣿⣸⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣦⡀
⠀⢰⡟⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣷⢿⣦⡀⠀⠀⠀⠁⠀⠀⠉⠉⠉⠉⠉⠉⠀⠀⢸⡄⣠⣿⣿⣿⠏⣿⣿⡙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠙⢿⣿⣿⣿⣿⣿
⢀⡿⠁⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢠⣿⡀⢻⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣨⣿⣿⢿⣿⠏⠀⡿⣿⣧⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠈⠻⣿⣿⣿
⣸⠃⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⢀⣿⡏⣇⠈⢻⣽⣧⡀⠀⠀⠀⠀⠀⠀⠀⣠⠔⣣⡾⣯⡼⠋⣾⠏⠀⢠⢇⣿⣿⠀⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠈⠻⣿
⠏⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⡟⠁⠀⣼⣿⠁⡏⠀⠘⣿⣿⠝⣦⡀⠀⠀⠀⠒⣋⣤⣿⣿⡿⠋⠀⢸⡏⠀⠀⡾⣼⣿⣿⡄⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀
⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⡜⠁⠀⢀⣿⢿⡇⣷⠀⠀⠘⣾⢧⣼⣿⣿⡖⣾⣻⣽⣿⠿⠋⠀⢀⣤⡟⠀⠀⣼⣷⣿⣿⣿⡇⠀⠀⠈⢯⠙⢿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀
⣾⣿⣿⣿⣿⠿⠟⠛⠋⠁⠀⠀⠀⡸⠃⠀⠀⣼⡟⢸⣇⢹⠀⠀⠀⠘⢯⣻⣿⣧⣿⠟⠋⠙⠉⠀⣀⡴⠋⡽⠁⠀⣰⣧⣿⣿⣿⣿⡇⠀⠀⠀⠘⡇⠀⠉⠙⠛⠿⣿⣿⣷⡀⠀⠀
⠛⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⡇⣿⣆⠀⣿⠸⡄⠀⠀⠀⠀⠙⢾⠋⠀⠀⠀⢀⡤⠞⠋⠀⡸⠃⠀⣰⢇⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⢀⠼⠋⠓⠲⠤
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡇⠀⠀⠀⣧⣿⣿⣿⣿⡄⣷⠀⠀⠀⠀⠀⠈⠳⣄⣤⠖⠋⠀⠀⠀⠈⠁⣸⣳⠟⣾⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠈⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠁⠀⠀⠀⣹⣿⣿⣿⣿⣧⢸⡄⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⢠⣿⠃⣸⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡇⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⡀⢻⢦⣄⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡿⠁⣸⣿⣿⣿⣿⣿⣿⣿⠀⠁⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠁⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣧⠸⡄⠈⠙⢿⡙⣆⠀⠀⠀⠀⣀⠴⠞⡟⠁⣰⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⡀⢱⡀⠀⠨⣻⣯⣄⠀⣠⠞⠁⢀⡜⠁⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣧⠈⢣⡀⠀⠀⠁⠺⠚⠁⠀⢀⡞⠁⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣇⡈⣧⣀⣀⣀⣀⠀⠀⣠⠞⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡗⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
*/
#include <bits/stdc++.h>

#ifdef ONLINE_JUDGE
#define debug(x)
#else
#include "soham.h"
#endif

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef long double lld;

#define INF 9e18
#define MOD 1000000007
#define nline "\n"
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define ff first
#define ss second
#define PI 3.141592653589793238462
#define set_bits __builtin_popcountll
#define sz(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define fastio()                      \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL)

struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
long long binpow(long long a, long long b)
{
    long long res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
class DSU
{
    int *parent;
    int *rank;

public:
    DSU(int n)
    {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            rank[i] = 1;
        }
    }
    // Find function
    int find(int i)
    {
        if (parent[i] == i)
            return i;
        return parent[i] = find(parent[i]);
    }
    // union function
    void unite(int x, int y)
    {
        int s1 = find(x);
        int s2 = find(y);

        if (s1 != s2)
        {
            if (rank[s1] < rank[s2])
            {
                parent[s1] = s2;
                rank[s2] += rank[s1];
            }
            else
            {
                parent[s2] = s1;
                rank[s1] += rank[s2];
            }
        }
    }
};
class Solution
{
public:
    bool canMakeSubsequence(string str1, string str2)
    {
        int i = 0, j = 0;
        while (i < str1.size() && j < str2.size())
        {
            char x = (str1[i] - 'a' + 1) % 26 + 'a';
            if (str1[i] == str2[j] || x == str2[j])
                j++;
            i++;
        }
        if (j == str2.size())
            return true;
        else
            return false;
    }
};
int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    freopen("error.txt", "w", stderr);
#endif
    vector<int> a = {0, 1, 1, 3};
    vector<vector<int>> b;
    Solution s;
    // auto x = s.canMakeSubsequence(a, 2);
    // debug(x);
    return 0;
}
